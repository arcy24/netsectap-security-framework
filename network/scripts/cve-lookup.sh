#!/bin/bash
#
# cve-lookup.sh - Standalone CVE lookup tool
# Query CVE databases for vulnerability information
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Source library functions
source "$SCRIPT_DIR/lib/cve-lib.sh"
source "$SCRIPT_DIR/lib/cache-lib.sh"
source "$SCRIPT_DIR/lib/cpe-builder.sh"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Default values
OUTPUT_FORMAT="json"
MIN_SEVERITY="LOW"
USE_CACHE=true
SILENT=false

usage() {
    cat << EOF
Usage: $0 [OPTIONS] [PRODUCT VERSION | --xml FILE | --cpe CPE_STRING]

Standalone CVE vulnerability lookup tool

ARGUMENTS:
    PRODUCT VERSION     Query CVEs for specific product and version
                        Example: Apache 2.4.49

OPTIONS:
    --xml FILE          Extract services from nmap XML and query all
    --cpe STRING        Query using CPE 2.3 string directly
    --no-cache          Bypass cache and force API query
    --format FORMAT     Output format: json, yaml, table, csv (default: json)
    --severity LEVEL    Minimum severity: LOW, MEDIUM, HIGH, CRITICAL (default: LOW)
    --output FILE       Write results to file instead of stdout
    --shodan-ip IP      Use Shodan API for IP-based CVE lookup
    --silent            Suppress informational messages
    --stats             Show cache statistics
    --clear-cache       Clear all cached CVE data
    -h, --help          Show this help message

EXAMPLES:
    # Query CVEs for Apache 2.4.49
    $0 Apache 2.4.49

    # Query from nmap XML file
    $0 --xml scans/nmap/192.168.1.1_vuln_20251223.xml

    # Query with CPE string directly
    $0 --cpe "cpe:2.3:a:apache:http_server:2.4.49"

    # Force cache refresh
    $0 --no-cache OpenSSH 7.4

    # Output as table
    $0 --format table nginx 1.18.0

    # Only show HIGH and CRITICAL CVEs
    $0 --severity HIGH Apache 2.4.49

    # Save to file
    $0 --output report.json --xml scan.xml

REQUIREMENTS:
    - curl (for API requests)
    - xmllint (for XML parsing)

EOF
    exit 0
}

log_info() {
    if [ "$SILENT" != true ]; then
        echo -e "${BLUE}[INFO]${NC} $1" >&2
    fi
}

log_success() {
    if [ "$SILENT" != true ]; then
        echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
    fi
}

log_warning() {
    if [ "$SILENT" != true ]; then
        echo -e "${YELLOW}[WARN]${NC} $1" >&2
    fi
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --xml)
                XML_FILE="$2"
                shift 2
                ;;
            --cpe)
                CPE_STRING="$2"
                shift 2
                ;;
            --no-cache)
                export CVE_NO_CACHE=true
                USE_CACHE=false
                shift
                ;;
            --format)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            --severity)
                MIN_SEVERITY="$2"
                shift 2
                ;;
            --output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            --shodan-ip)
                SHODAN_IP="$2"
                shift 2
                ;;
            --silent)
                SILENT=true
                shift
                ;;
            --stats)
                cache_stats
                exit 0
                ;;
            --clear-cache)
                clear_cache
                exit 0
                ;;
            -h|--help)
                usage
                ;;
            *)
                # Assume product and version
                if [ -z "$PRODUCT" ]; then
                    PRODUCT="$1"
                elif [ -z "$VERSION" ]; then
                    VERSION="$1"
                else
                    log_error "Unknown argument: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done
}

# Query single product/version
query_single() {
    local product="$1"
    local version="$2"

    log_info "Querying CVEs for: $product $version"

    if [ "$USE_CACHE" = true ]; then
        local cache_key=$(generate_cache_key "$product" "$version")
        if check_cache "$cache_key"; then
            log_info "Cache hit: $cache_key"
        else
            log_info "Cache miss, querying NVD API..."
        fi
    fi

    local result=$(query_cve_with_cache "$product" "$version")
    local status=$?

    if [ $status -ne 0 ]; then
        log_error "Failed to query CVEs for $product $version"
        return 1
    fi

    # Count CVEs
    local total=$(echo "$result" | grep -o '"totalResults":[0-9]*' | cut -d':' -f2)
    total=${total:-0}

    if [ "$total" -gt 0 ]; then
        log_success "Found $total CVE(s) for $product $version"
    else
        log_info "No CVEs found for $product $version"
    fi

    echo "$result"
    return 0
}

# Query from XML file
query_from_xml() {
    local xml_file="$1"

    if [ ! -f "$xml_file" ]; then
        log_error "XML file not found: $xml_file"
        return 1
    fi

    log_info "Extracting services from XML: $xml_file"

    local services=$(extract_services_from_xml "$xml_file")

    if [ -z "$services" ]; then
        log_warning "No services with version information found in XML"
        return 1
    fi

    local service_count=$(echo "$services" | wc -l)
    log_info "Found $service_count service(s) with version information"

    # Build output JSON
    echo "{"
    echo "  \"scan_metadata\": {"
    echo "    \"scan_file\": \"$xml_file\","
    echo "    \"scan_date\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\","
    echo "    \"total_services\": $service_count"
    echo "  },"
    echo "  \"services\": ["

    local first=true
    echo "$services" | while IFS='|' read -r ip port protocol service product version; do
        if [ "$first" != true ]; then
            echo ","
        fi
        first=false

        log_info "Querying: $product $version (${ip}:${port})"

        # Query CVEs
        local cve_result=$(query_cve_with_cache "$product" "$version" 2>/dev/null)
        local cpe=$(build_cpe_from_nmap "$product" "$version")
        local total_cves=$(echo "$cve_result" | grep -o '"totalResults":[0-9]*' | cut -d':' -f2)
        total_cves=${total_cves:-0}

        # Output service entry
        cat << SERVICEEOF
    {
      "ip": "$ip",
      "port": $port,
      "protocol": "$protocol",
      "service": "$service",
      "product": "$product",
      "version": "$version",
      "cpe": "$cpe",
      "cve_count": $total_cves
    }
SERVICEEOF
    done

    echo "  ]"
    echo "}"

    log_success "CVE lookup completed for $service_count service(s)"
    return 0
}

# Query using CPE string
query_by_cpe() {
    local cpe="$1"

    log_info "Querying CVEs for CPE: $cpe"

    if ! validate_cpe "$cpe"; then
        log_error "Invalid CPE format: $cpe"
        return 1
    fi

    local result=$(query_nvd_api "$cpe")
    local status=$?

    if [ $status -ne 0 ]; then
        log_error "Failed to query CVEs for CPE: $cpe"
        return 1
    fi

    local total=$(echo "$result" | grep -o '"totalResults":[0-9]*' | cut -d':' -f2)
    total=${total:-0}

    if [ "$total" -gt 0 ]; then
        log_success "Found $total CVE(s)"
    else
        log_info "No CVEs found"
    fi

    echo "$result"
    return 0
}

# Main execution
main() {
    parse_args "$@"

    # Initialize cache
    init_cache

    # Determine query mode
    if [ -n "$XML_FILE" ]; then
        # XML file mode
        result=$(query_from_xml "$XML_FILE")
    elif [ -n "$CPE_STRING" ]; then
        # CPE mode
        result=$(query_by_cpe "$CPE_STRING")
    elif [ -n "$PRODUCT" ] && [ -n "$VERSION" ]; then
        # Product/version mode
        result=$(query_single "$PRODUCT" "$VERSION")
    else
        log_error "No query parameters specified. Use --help for usage."
        exit 1
    fi

    # Output result
    if [ -n "$OUTPUT_FILE" ]; then
        echo "$result" > "$OUTPUT_FILE"
        log_success "Results saved to: $OUTPUT_FILE"
    else
        echo "$result"
    fi

    exit 0
}

# Run main function
main "$@"
