#!/bin/bash
#
# cve-lib.sh - Core CVE lookup library
# Provides functions for querying CVE databases and parsing results
#

# Get script directory for relative paths
CVE_LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CVE_PROJECT_ROOT="$(dirname "$(dirname "$CVE_LIB_DIR")")"

# Source dependencies
source "$CVE_LIB_DIR/cache-lib.sh"
source "$CVE_LIB_DIR/cpe-builder.sh"

# Load configuration
CVE_CONFIG_FILE="$CVE_PROJECT_ROOT/config/cve-config.conf"
if [ -f "$CVE_CONFIG_FILE" ]; then
    source "$CVE_CONFIG_FILE"
fi

# Default values
NVD_API_URL="${NVD_API_URL:-https://services.nvd.nist.gov/rest/json/cves/2.0}"
NVD_API_KEY="${NVD_API_KEY:-}"
NVD_RATE_LIMIT_DELAY="${NVD_RATE_LIMIT_DELAY:-6}"
OFFLINE_MODE="${OFFLINE_MODE:-false}"

# Rate limit tracking file
RATE_LIMIT_FILE="/tmp/nvd_api_rate_limit_$$.timestamp"

# Cleanup rate limit file on exit
trap 'rm -f "$RATE_LIMIT_FILE" 2>/dev/null' EXIT

# Rate limiting function
# Waits appropriate time since last API call
rate_limit_wait() {
    local min_interval="${NVD_RATE_LIMIT_DELAY}"

    if [ -f "$RATE_LIMIT_FILE" ]; then
        local last_request=$(cat "$RATE_LIMIT_FILE" 2>/dev/null || echo 0)
        local current_time=$(date +%s)
        local elapsed=$((current_time - last_request))

        if [ $elapsed -lt $min_interval ]; then
            local wait_time=$((min_interval - elapsed))
            sleep $wait_time
        fi
    fi

    # Update timestamp
    date +%s > "$RATE_LIMIT_FILE"
}

# Query NVD API for CVEs by CPE name
# Args: $1=CPE string (e.g., "cpe:2.3:a:apache:http_server:2.4.49")
# Returns: JSON response from NVD API
query_nvd_api() {
    local cpe_name="$1"

    if [ -z "$cpe_name" ]; then
        echo '{"resultsPerPage":0,"totalResults":0,"vulnerabilities":[]}' >&2
        return 1
    fi

    # Check offline mode
    if [ "$OFFLINE_MODE" = true ]; then
        echo '{"error":"Offline mode enabled"}' >&2
        return 1
    fi

    # URL encode CPE name
    local encoded_cpe=$(urlencode_cpe "$cpe_name")

    # Build API URL
    local api_url="${NVD_API_URL}?cpeName=${encoded_cpe}"

    # Add API key if available
    if [ -n "$NVD_API_KEY" ]; then
        api_url="${api_url}&apiKey=${NVD_API_KEY}"
    fi

    # Rate limiting
    rate_limit_wait

    # Execute request with HTTP status code
    local response=$(curl -s -w "\n%{http_code}" "$api_url" 2>/dev/null)
    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')

    # Handle HTTP responses
    case $http_code in
        200)
            echo "$body"
            return 0
            ;;
        403)
            echo '{"error":"Rate limit exceeded"}' >&2
            return 1
            ;;
        404)
            # No CVEs found - return empty result
            echo '{"resultsPerPage":0,"totalResults":0,"vulnerabilities":[]}'
            return 0
            ;;
        *)
            echo "{\"error\":\"HTTP $http_code\"}" >&2
            return 1
            ;;
    esac
}

# Query CVE with caching
# Args: $1=product, $2=version
# Returns: JSON response (from cache or API)
query_cve_with_cache() {
    local product="$1"
    local version="$2"

    if [ -z "$product" ] || [ -z "$version" ]; then
        return 1
    fi

    # Generate cache key
    local cache_key=$(generate_cache_key "$product" "$version")

    if [ -z "$cache_key" ]; then
        return 1
    fi

    # Check cache first (unless bypassed)
    if [ "${CVE_NO_CACHE:-false}" != true ] && check_cache "$cache_key"; then
        get_cache "$cache_key"
        return 0
    fi

    # Build CPE string
    local cpe=$(build_cpe_from_nmap "$product" "$version")

    if [ -z "$cpe" ]; then
        return 1
    fi

    # Query NVD API
    local nvd_response=$(query_nvd_api "$cpe")
    local query_status=$?

    if [ $query_status -eq 0 ]; then
        # Store in cache
        store_cache "$cache_key" "$nvd_response" 2>/dev/null
        echo "$nvd_response"
        return 0
    else
        echo "$nvd_response"
        return 1
    fi
}

# Extract service version information from nmap XML
# Args: $1=xml_file
# Returns: Pipe-delimited list: ip|port|protocol|service|product|version (one per line)
extract_services_from_xml() {
    local xml_file="$1"

    if [ ! -f "$xml_file" ]; then
        return 1
    fi

    # Check if xmllint is available
    if ! command -v xmllint &>/dev/null; then
        echo "[ERROR] xmllint not found. Install libxml2-utils." >&2
        return 1
    fi

    # Extract host IP addresses and associated services
    # This uses xmllint to parse the XML structure
    xmllint --xpath '//host' "$xml_file" 2>/dev/null | while IFS= read -r host_block; do
        # Extract IP address
        local ip=$(echo "$host_block" | xmllint --xpath 'string(//address[@addrtype="ipv4"]/@addr)' - 2>/dev/null)

        # Extract ports with service information
        echo "$host_block" | xmllint --xpath '//port' - 2>/dev/null | while IFS= read -r port_block; do
            local port=$(echo "$port_block" | xmllint --xpath 'string(//@portid)' - 2>/dev/null)
            local protocol=$(echo "$port_block" | xmllint --xpath 'string(//@protocol)' - 2>/dev/null)
            local service=$(echo "$port_block" | xmllint --xpath 'string(//service/@name)' - 2>/dev/null)
            local product=$(echo "$port_block" | xmllint --xpath 'string(//service/@product)' - 2>/dev/null)
            local version=$(echo "$port_block" | xmllint --xpath 'string(//service/@version)' - 2>/dev/null)

            # Only output services with product and version
            if [ -n "$product" ] && [ -n "$version" ]; then
                echo "${ip}|${port}|${protocol}|${service}|${product}|${version}"
            fi
        done
    done
}

# Calculate CVSS severity from score
# Args: $1=cvss_score (float)
# Returns: CRITICAL|HIGH|MEDIUM|LOW
calculate_severity() {
    local score="$1"

    # Remove decimal for comparison (bash doesn't handle floats well)
    local score_int=$(echo "$score" | sed 's/\..*//')

    if [ -z "$score_int" ] || [ "$score_int" = "null" ]; then
        echo "UNKNOWN"
        return 0
    fi

    if [ "$score_int" -ge 9 ]; then
        echo "CRITICAL"
    elif [ "$score_int" -ge 7 ]; then
        echo "HIGH"
    elif [ "$score_int" -ge 4 ]; then
        echo "MEDIUM"
    else
        echo "LOW"
    fi
}

# Parse CVE data from NVD JSON response
# Args: $1=nvd_json
# Returns: Simplified JSON array of CVEs with relevant fields
parse_cve_data() {
    local nvd_json="$1"

    if [ -z "$nvd_json" ]; then
        return 1
    fi

    # Extract total results
    local total=$(echo "$nvd_json" | grep -o '"totalResults":[0-9]*' | cut -d':' -f2)

    if [ -z "$total" ] || [ "$total" -eq 0 ]; then
        echo "[]"
        return 0
    fi

    # Parse vulnerabilities array
    # This is a simplified parser using grep/sed (no jq dependency)
    # For production use, consider adding jq as dependency for better JSON parsing

    echo "$nvd_json" | sed -n '/"vulnerabilities":/,/]/p' | \
    grep -E '"id"|"cvssMetricV3"|"baseScore"|"baseSeverity"|"description"' | \
    sed 's/^[[:space:]]*//' | tr -d '\n' | \
    sed 's/"id":/\n&/g' | tail -n +2

    return 0
}

# Calculate risk score from CVE list
# Args: $1=cve_json_array
# Returns: Integer risk score
calculate_risk_score() {
    local cve_data="$1"

    if [ -z "$cve_data" ]; then
        echo "0"
        return 0
    fi

    local critical_count=$(echo "$cve_data" | grep -c '"severity":"CRITICAL"' 2>/dev/null || echo 0)
    local high_count=$(echo "$cve_data" | grep -c '"severity":"HIGH"' 2>/dev/null || echo 0)
    local medium_count=$(echo "$cve_data" | grep -c '"severity":"MEDIUM"' 2>/dev/null || echo 0)
    local low_count=$(echo "$cve_data" | grep -c '"severity":"LOW"' 2>/dev/null || echo 0)

    # Score weighting: CRITICAL=15, HIGH=10, MEDIUM=5, LOW=2
    local score=$((critical_count * 15 + high_count * 10 + medium_count * 5 + low_count * 2))

    echo "$score"
    return 0
}

# Query Shodan for CVE data (if available)
# Args: $1=ip_address
# Returns: JSON with CVE IDs
query_shodan_cves() {
    local ip="$1"

    if [ -z "$ip" ] || [ "${SHODAN_ENABLED:-false}" != true ]; then
        return 1
    fi

    local shodan_cli="${SHODAN_CLI_PATH:-../../shodan-cli/build/shodan}"

    if [ ! -x "$shodan_cli" ]; then
        return 1
    fi

    # Query Shodan
    "$shodan_cli" host "$ip" --format json 2>/dev/null | \
        grep -oP '"vulns":\[[^\]]*\]' || echo '{"vulns":[]}'

    return 0
}

# Build complete CVE report for service
# Args: $1=ip, $2=port, $3=service, $4=product, $5=version
# Returns: JSON object with service info and CVEs
build_service_cve_report() {
    local ip="$1"
    local port="$2"
    local service="$3"
    local product="$4"
    local version="$5"

    # Query CVEs
    local cve_data=$(query_cve_with_cache "$product" "$version")

    # Build CPE
    local cpe=$(build_cpe_from_nmap "$product" "$version")

    # Parse CVE count
    local total_cves=$(echo "$cve_data" | grep -o '"totalResults":[0-9]*' | cut -d':' -f2)
    total_cves=${total_cves:-0}

    # Build JSON (basic format, can be enhanced)
    cat << EOF
{
  "ip": "$ip",
  "port": $port,
  "service": "$service",
  "product": "$product",
  "version": "$version",
  "cpe": "$cpe",
  "cve_count": $total_cves,
  "nvd_response": $cve_data
}
EOF

    return 0
}
